$date
	Fri May 31 10:40:53 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module cache_tb $end
$var wire 32 ! word_out [31:0] $end
$var wire 1 " rdy $end
$var wire 1 # mem_wr_en $end
$var wire 512 $ mem_wr_blk [511:0] $end
$var wire 1 % mem_rd_en $end
$var wire 512 & mem_rd_blk [511:0] $end
$var wire 32 ' mem_addr [31:0] $end
$var wire 1 ( hit $end
$var wire 8 ) byte_out [7:0] $end
$var parameter 32 * CLK_CYCLES $end
$var parameter 32 + CLK_PERIOD $end
$var parameter 32 , RST_PULSE $end
$var reg 32 - addr [31:0] $end
$var reg 1 . clk $end
$var reg 32 / data_wr [31:0] $end
$var reg 1 0 rd_en $end
$var reg 1 1 rst_n $end
$var reg 1 2 wr_en $end
$scope module CACHE_DUT $end
$var wire 32 3 addr [31:0] $end
$var wire 1 . clk $end
$var wire 32 4 data_wr [31:0] $end
$var wire 1 0 rd_en $end
$var wire 1 1 rst_n $end
$var wire 1 2 wr_en $end
$var wire 512 5 mem_rd_blk [511:0] $end
$var parameter 3 6 EVICT $end
$var parameter 3 7 IDLE $end
$var parameter 3 8 RD_HIT $end
$var parameter 3 9 RD_MISS $end
$var parameter 3 : WR_HIT $end
$var parameter 3 ; WR_MISS $end
$var reg 8 < byte_out [7:0] $end
$var reg 1 ( hit $end
$var reg 32 = mem_addr [31:0] $end
$var reg 1 % mem_rd_en $end
$var reg 512 > mem_wr_blk [511:0] $end
$var reg 1 # mem_wr_en $end
$var reg 3 ? next [2:0] $end
$var reg 1 @ rd_m $end
$var reg 1 " rdy $end
$var reg 3 A state [2:0] $end
$var reg 32 B word_out [31:0] $end
$var reg 1 C wr_m $end
$var integer 32 D i [31:0] $end
$var integer 32 E j [31:0] $end
$upscope $end
$scope module MEM_DUT $end
$var wire 32 F addr [31:0] $end
$var wire 1 . clk $end
$var wire 1 % rd_en $end
$var wire 512 G wr_data [511:0] $end
$var wire 1 # wr_en $end
$var parameter 32 H BYTES_PER_WORD $end
$var parameter 42 I DEPTH $end
$var parameter 32 J INIT $end
$var parameter 32 K NSEED_BLK $end
$var parameter 32 L SEED $end
$var parameter 32 M WIDTH $end
$var parameter 32 N WORDS_PER_BLOCK $end
$var reg 512 O rd_data [511:0] $end
$var integer 32 P byte_idx [31:0] $end
$var integer 32 Q i [31:0] $end
$var integer 32 R j [31:0] $end
$var integer 32 S word_idx [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10000 N
b1000 M
b1 L
b100 K
b0 J
b10000000000 I
b100 H
b100 ;
b11 :
b10 9
b1 8
b0 7
b101 6
b11001 ,
b1100100 +
b10100 *
$end
#0
$dumpvars
bx S
b1000000 R
b100000000 Q
bx P
bx O
bx G
bx F
b10000000 E
b100 D
xC
bx B
b0 A
x@
b0 ?
bx >
bx =
bx <
bx 5
bx 4
b0 3
02
01
10
bx /
1.
b0 -
bx )
x(
bx '
bx &
x%
bx $
x#
x"
bx !
$end
#25
11
#50
0.
#100
b101 ?
0"
1@
0C
bz )
bz <
bz !
bz B
0%
0#
0(
1.
#150
0.
#200
b10110001101100101011001110110100101101011011011010110111101110001011100110111010101110111011110010111101101111101011111111000000110000011100001011000011110001001100010111000110110001111100100011001001110010101100101111001100110011011100111011001111110100001101000111010010110100111101010011010101110101101101011111011000110110011101101011011011110111001101110111011110110111111110000011100001111000101110001111100100111001011110011011100111111010001110100111101010111010111110110011101101111011101110111111110000 &
b10110001101100101011001110110100101101011011011010110111101110001011100110111010101110111011110010111101101111101011111111000000110000011100001011000011110001001100010111000110110001111100100011001001110010101100101111001100110011011100111011001111110100001101000111010010110100111101010011010101110101101101011111011000110110011101101011011011110111001101110111011110110111111110000011100001111000101110001111100100111001011110011011100111111010001110100111101010111010111110110011101101111011101110111111110000 5
b10110001101100101011001110110100101101011011011010110111101110001011100110111010101110111011110010111101101111101011111111000000110000011100001011000011110001001100010111000110110001111100100011001001110010101100101111001100110011011100111011001111110100001101000111010010110100111101010011010101110101101101011111011000110110011101101011011011110111001101110111011110110111111110000011100001111000101110001111100100111001011110011011100111111010001110100111101010111010111110110011101101111011101110111111110000 O
b100 P
b10000 S
b10 ?
1%
b0 '
b0 =
b0 F
b101 A
1.
#250
0.
#300
b10101 -
b10101 3
b0 ?
b10 A
b11110000 )
b11110000 <
b11101101111011101110111111110000 !
b11101101111011101110111111110000 B
1"
1.
#350
0.
#400
b1 ?
0"
0@
bz )
bz <
bz !
bz B
0%
1(
b0 A
1.
#450
0.
#500
b11001 -
b11001 3
b0 ?
b1 A
b11011011 )
b11011011 <
b11011001110110101101101111011100 !
b11011001110110101101101111011100 B
1"
1.
#550
0.
#600
b1 ?
0"
bz )
bz <
bz !
bz B
b0 A
1.
#650
0.
#700
b11101 -
b11101 3
b0 ?
b1 A
b11010111 )
b11010111 <
b11010101110101101101011111011000 !
b11010101110101101101011111011000 B
1"
1.
#750
0.
#800
b1 ?
0"
bz )
bz <
bz !
bz B
b0 A
1.
#850
0.
#900
b100001 -
b100001 3
b0 ?
b1 A
b11010011 )
b11010011 <
b11010001110100101101001111010100 !
b11010001110100101101001111010100 B
1"
1.
#950
0.
#1000
b1 ?
0"
bz )
bz <
bz !
bz B
b0 A
1.
#1050
0.
#1100
b0 ?
b1 A
b11001111 )
b11001111 <
b11001101110011101100111111010000 !
b11001101110011101100111111010000 B
1"
1.
#1150
0.
#1200
b1 ?
0"
bz )
bz <
bz !
bz B
b0 A
1.
#1250
0.
#1300
b0 ?
b1 A
b11001111 )
b11001111 <
b11001101110011101100111111010000 !
b11001101110011101100111111010000 B
1"
1.
